
c↦“Closures without outputs are predicates”

c↦“

A set can be represented by a function from the universe of discourse to a boolean value (i.e. a predicate)

How does well-definedness (non-recursiveness) of the set correspond with totality of the associated predicate?

Is demanding totality of the predicate sufficient to prevent the pathological cases of naive set theory?

If so, this would mean the predicate associated with paradoxical sets is non-total.

Russel's paradox: 
	let R = { x | x ∉ x }
	then R ∈ R ⇔ R ∉ R

P(x) = x ∉ x

”


c↦“
Recursion is total iff there exist a wellfounded relation < on all the input parameters and the recursive call has this relation compared with the containing function:

	f φ ↦ …
		… ≔ f ψ

then Total f ⇔ ψ < φ.

Note: Recursive behaviour can be hidden in complex structures of higher-order functions and co-recursion. How does the above statement translate to such an environment?

From this should follow any induction method, μ-recursion and Walther-recursion.

”

Boolean φ ↦ 0

c↦“Closures without body are abstract functions in extension.”

C φ ψ ↦ χ
	p1 ≔ Boolean φ
	p2 ≔ Boolean ψ
	a1 ≔ Boolean χ
	p3 ≔ Boolean χ
	χ ↦
	∵ p1
	∵ p2
	⊨ a1
	∴ p3

c↦“Closures can be annotated by logical statements:
	∵ ‘because’: Specifies a precondition. Calls to the closure must satisfy these.
	⊨ ‘axiom’: Given the preconditions, the following statement is accepted as true without proof.
	⊢ ‘proofs’: Specifies that a condition should be provable. Used as an assertion for debugging purposes.
	∴ ‘therefore’: Specifies a postcondition. Calls to the closure will have these satisfied.
”

ax1 φ ψ ↦ χ
	∵ (≔ Boolean φ)
	∵ (≔ Boolean ψ)
	χ  ≔ C φ (≔ C ψ φ)
	⊨ χ
	∴ (≔ Boolean χ)
	∴ χ

ax2 φ ψ χ ↦ η
	∵ (≔ Boolean φ)
	∵ (≔ Boolean ψ)
	∵ (≔ Boolean χ)
	η ≔ C (≔ C φ (≔ C ψ χ)) (≔ C (≔ C φ ψ) (≔ C φ χ) )
	⊨ η
	∴ (≔ Boolean η)
	∴ η

ax3 φ ψ ↦ ψ
	∵ (≔ Boolean φ)
	∵ (≔ Boolean ψ)
	∵ φ
	∵ (≔ C φ ψ)
	⊨ ψ
	∴ (≔ Boolean ψ)
	∴ ψ


th1 φ ↦ ψ
	∵ (≔ Boolean φ)
	ψ ≔ C φ φ
	a ≔ ax1 φ φ
		⊢ (≔ C φ ψ)
	b ≔ ax1 φ ψ
		⊢ (≔ C φ (≔ C ψ φ))
	c ≔ ax2 φ ψ φ
		⊢ (≔ C (≔ C φ (≔ C ψ φ)) (≔ C (≔ C φ ψ) ψ))
		⊢ (≔ C b (≔ C a ψ))
	d ≔ ax3 b (≔ C a ψ)
		⊢ (≔ C a ψ)
	e ≔ ax3 a ψ
		⊢ ψ
	∴ (≔ Boolean e)
	∴ e


